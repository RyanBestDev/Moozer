import { createAuthEndpoint, BASE_ERROR_CODES, getSessionFromCtx } from './chunk-HMECAGV7.js';
import { setSessionCookie } from './chunk-WBFH3ZYN.js';
import { mergeSchema } from './chunk-WZ6OIVJK.js';
import { generateRandomString } from './chunk-DBPOZRMS.js';
import { getDate } from './chunk-FURNA6HY.js';
import { z } from 'zod';
import { APIError } from 'better-call';

function generateOTP(size) {
  return generateRandomString(size, "0-9");
}
var phoneNumber = (options) => {
  const opts = {
    expiresIn: options?.expiresIn || 300,
    otpLength: options?.otpLength || 6,
    ...options,
    phoneNumber: "phoneNumber",
    phoneNumberVerified: "phoneNumberVerified",
    code: "code",
    createdAt: "createdAt"
  };
  const ERROR_CODES = {
    INVALID_PHONE_NUMBER: "Invalid phone number",
    INVALID_PHONE_NUMBER_OR_PASSWORD: "Invalid phone number or password",
    UNEXPECTED_ERROR: "Unexpected error",
    OTP_NOT_FOUND: "OTP not found"
  };
  return {
    id: "phone-number",
    endpoints: {
      signInPhoneNumber: createAuthEndpoint(
        "/sign-in/phone-number",
        {
          method: "POST",
          body: z.object({
            phoneNumber: z.string({
              description: "Phone number to sign in"
            }),
            password: z.string({
              description: "Password to use for sign in"
            }),
            rememberMe: z.boolean({
              description: "Remember the session"
            }).optional()
          }),
          metadata: {
            openapi: {
              summary: "Sign in with phone number",
              description: "Use this endpoint to sign in with phone number",
              responses: {
                200: {
                  description: "Success",
                  content: {
                    "application/json": {
                      schema: {
                        type: "object",
                        properties: {
                          user: {
                            $ref: "#/components/schemas/User"
                          },
                          session: {
                            $ref: "#/components/schemas/Session"
                          }
                        }
                      }
                    }
                  }
                },
                400: {
                  description: "Invalid phone number or password"
                }
              }
            }
          }
        },
        async (ctx) => {
          const { password, phoneNumber: phoneNumber2 } = ctx.body;
          if (opts.phoneNumberValidator) {
            const isValidNumber = await opts.phoneNumberValidator(
              ctx.body.phoneNumber
            );
            if (!isValidNumber) {
              throw new APIError("BAD_REQUEST", {
                message: ERROR_CODES.INVALID_PHONE_NUMBER
              });
            }
          }
          const user = await ctx.context.adapter.findOne({
            model: "user",
            where: [
              {
                field: "phoneNumber",
                value: phoneNumber2
              }
            ]
          });
          if (!user) {
            throw new APIError("UNAUTHORIZED", {
              message: ERROR_CODES.INVALID_PHONE_NUMBER_OR_PASSWORD
            });
          }
          const accounts = await ctx.context.internalAdapter.findAccountByUserId(user.id);
          const credentialAccount = accounts.find(
            (a) => a.providerId === "credential"
          );
          if (!credentialAccount) {
            ctx.context.logger.error("Credential account not found", {
              phoneNumber: phoneNumber2
            });
            throw new APIError("UNAUTHORIZED", {
              message: ERROR_CODES.INVALID_PHONE_NUMBER_OR_PASSWORD
            });
          }
          const currentPassword = credentialAccount?.password;
          if (!currentPassword) {
            ctx.context.logger.error("Password not found", { phoneNumber: phoneNumber2 });
            throw new APIError("UNAUTHORIZED", {
              message: ERROR_CODES.UNEXPECTED_ERROR
            });
          }
          const validPassword = await ctx.context.password.verify({
            hash: currentPassword,
            password
          });
          if (!validPassword) {
            ctx.context.logger.error("Invalid password");
            throw new APIError("UNAUTHORIZED", {
              message: ERROR_CODES.INVALID_PHONE_NUMBER_OR_PASSWORD
            });
          }
          const session = await ctx.context.internalAdapter.createSession(
            user.id,
            ctx.headers,
            ctx.body.rememberMe === false
          );
          if (!session) {
            ctx.context.logger.error("Failed to create session");
            throw new APIError("UNAUTHORIZED", {
              message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION
            });
          }
          await setSessionCookie(
            ctx,
            {
              session,
              user
            },
            ctx.body.rememberMe === false
          );
          return ctx.json({
            token: session.token,
            user: {
              id: user.id,
              email: user.email,
              emailVerified: user.emailVerified,
              name: user.name,
              image: user.image,
              phoneNumber: user.phoneNumber,
              phoneNumberVerified: user.phoneNumberVerified,
              createdAt: user.createdAt,
              updatedAt: user.updatedAt
            }
          });
        }
      ),
      sendPhoneNumberOTP: createAuthEndpoint(
        "/phone-number/send-otp",
        {
          method: "POST",
          body: z.object({
            phoneNumber: z.string({
              description: "Phone number to send OTP"
            })
          }),
          metadata: {
            openapi: {
              summary: "Send OTP to phone number",
              description: "Use this endpoint to send OTP to phone number",
              responses: {
                200: {
                  description: "Success",
                  content: {
                    "application/json": {
                      schema: {
                        type: "object",
                        properties: {
                          message: {
                            type: "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        async (ctx) => {
          if (!options?.sendOTP) {
            ctx.context.logger.warn("sendOTP not implemented");
            throw new APIError("NOT_IMPLEMENTED", {
              message: "sendOTP not implemented"
            });
          }
          if (opts.phoneNumberValidator) {
            const isValidNumber = await opts.phoneNumberValidator(
              ctx.body.phoneNumber
            );
            if (!isValidNumber) {
              throw new APIError("BAD_REQUEST", {
                message: ERROR_CODES.INVALID_PHONE_NUMBER
              });
            }
          }
          const code = generateOTP(opts.otpLength);
          await ctx.context.internalAdapter.createVerificationValue({
            value: code,
            identifier: ctx.body.phoneNumber,
            expiresAt: getDate(opts.expiresIn, "sec")
          });
          await options.sendOTP(
            {
              phoneNumber: ctx.body.phoneNumber,
              code
            },
            ctx.request
          );
          return ctx.json(
            { code },
            {
              body: {
                message: "Code sent"
              }
            }
          );
        }
      ),
      verifyPhoneNumber: createAuthEndpoint(
        "/phone-number/verify",
        {
          method: "POST",
          body: z.object({
            /**
             * Phone number
             */
            phoneNumber: z.string({
              description: "Phone number to verify"
            }),
            /**
             * OTP code
             */
            code: z.string({
              description: "OTP code"
            }),
            /**
             * Disable session creation after verification
             * @default false
             */
            disableSession: z.boolean({
              description: "Disable session creation after verification"
            }).optional(),
            /**
             * This checks if there is a session already
             * and updates the phone number with the provided
             * phone number
             */
            updatePhoneNumber: z.boolean({
              description: "Check if there is a session and update the phone number"
            }).optional()
          }),
          metadata: {
            openapi: {
              summary: "Verify phone number",
              description: "Use this endpoint to verify phone number",
              responses: {
                200: {
                  description: "Success",
                  content: {
                    "application/json": {
                      schema: {
                        type: "object",
                        properties: {
                          user: {
                            $ref: "#/components/schemas/User"
                          },
                          session: {
                            $ref: "#/components/schemas/Session"
                          }
                        }
                      }
                    }
                  }
                },
                400: {
                  description: "Invalid OTP"
                }
              }
            }
          }
        },
        async (ctx) => {
          const otp = await ctx.context.internalAdapter.findVerificationValue(
            ctx.body.phoneNumber
          );
          if (!otp || otp.expiresAt < /* @__PURE__ */ new Date()) {
            if (otp && otp.expiresAt < /* @__PURE__ */ new Date()) {
              await ctx.context.internalAdapter.deleteVerificationValue(otp.id);
              throw new APIError("BAD_REQUEST", {
                message: "OTP expired"
              });
            }
            throw new APIError("BAD_REQUEST", {
              message: ERROR_CODES.OTP_NOT_FOUND
            });
          }
          if (otp.value !== ctx.body.code) {
            throw new APIError("BAD_REQUEST", {
              message: "Invalid OTP"
            });
          }
          await ctx.context.internalAdapter.deleteVerificationValue(otp.id);
          if (ctx.body.updatePhoneNumber) {
            const session = await getSessionFromCtx(ctx);
            if (!session) {
              throw new APIError("UNAUTHORIZED", {
                message: BASE_ERROR_CODES.USER_NOT_FOUND
              });
            }
            let user2 = await ctx.context.internalAdapter.updateUser(
              session.user.id,
              {
                [opts.phoneNumber]: ctx.body.phoneNumber,
                [opts.phoneNumberVerified]: true
              }
            );
            return ctx.json({
              status: true,
              token: session.session.token,
              user: {
                id: user2.id,
                email: user2.email,
                emailVerified: user2.emailVerified,
                name: user2.name,
                image: user2.image,
                phoneNumber: user2.phoneNumber,
                phoneNumberVerified: user2.phoneNumberVerified,
                createdAt: user2.createdAt,
                updatedAt: user2.updatedAt
              }
            });
          }
          let user = await ctx.context.adapter.findOne({
            model: "user",
            where: [
              {
                value: ctx.body.phoneNumber,
                field: opts.phoneNumber
              }
            ]
          });
          if (!user) {
            if (options?.signUpOnVerification) {
              user = await ctx.context.internalAdapter.createUser({
                email: options.signUpOnVerification.getTempEmail(
                  ctx.body.phoneNumber
                ),
                name: options.signUpOnVerification.getTempName ? options.signUpOnVerification.getTempName(
                  ctx.body.phoneNumber
                ) : ctx.body.phoneNumber,
                [opts.phoneNumber]: ctx.body.phoneNumber,
                [opts.phoneNumberVerified]: true
              });
              if (!user) {
                throw new APIError("INTERNAL_SERVER_ERROR", {
                  message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER
                });
              }
            }
          } else {
            user = await ctx.context.internalAdapter.updateUser(user.id, {
              [opts.phoneNumberVerified]: true
            });
          }
          if (!user) {
            return ctx.json(null);
          }
          await options?.callbackOnVerification?.(
            {
              phoneNumber: ctx.body.phoneNumber,
              user
            },
            ctx.request
          );
          if (!user) {
            throw new APIError("INTERNAL_SERVER_ERROR", {
              message: BASE_ERROR_CODES.FAILED_TO_UPDATE_USER
            });
          }
          if (!ctx.body.disableSession) {
            const session = await ctx.context.internalAdapter.createSession(
              user.id,
              ctx.request
            );
            if (!session) {
              throw new APIError("INTERNAL_SERVER_ERROR", {
                message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION
              });
            }
            await setSessionCookie(ctx, {
              session,
              user
            });
            return ctx.json({
              status: true,
              token: session.token,
              user: {
                id: user.id,
                email: user.email,
                emailVerified: user.emailVerified,
                name: user.name,
                image: user.image,
                phoneNumber: user.phoneNumber,
                phoneNumberVerified: user.phoneNumberVerified,
                createdAt: user.createdAt,
                updatedAt: user.updatedAt
              }
            });
          }
          return ctx.json({
            status: true,
            token: null,
            user: {
              id: user.id,
              email: user.email,
              emailVerified: user.emailVerified,
              name: user.name,
              image: user.image,
              phoneNumber: user.phoneNumber,
              phoneNumberVerified: user.phoneNumberVerified,
              createdAt: user.createdAt,
              updatedAt: user.updatedAt
            }
          });
        }
      )
    },
    schema: mergeSchema(schema, options?.schema),
    $ERROR_CODES: ERROR_CODES
  };
};
var schema = {
  user: {
    fields: {
      phoneNumber: {
        type: "string",
        required: false,
        unique: true,
        sortable: true,
        returned: true
      },
      phoneNumberVerified: {
        type: "boolean",
        required: false,
        returned: true,
        input: false
      }
    }
  }
};

export { phoneNumber };
