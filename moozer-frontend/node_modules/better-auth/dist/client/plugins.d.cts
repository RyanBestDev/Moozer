import * as nanostores from 'nanostores';
import { atom } from 'nanostores';
import { AccessControl, StatementsPrimitive, Role } from '../plugins/access.cjs';
import * as _better_fetch_fetch from '@better-fetch/fetch';
import { BetterFetch, BetterFetchOption } from '@better-fetch/fetch';
import { o as organization, a as Organization, M as Member, I as Invitation } from '../index-D4qb6sUY.cjs';
import { b as Prettify } from '../helper-Bi8FQwDD.cjs';
import { username } from '../plugins/username.cjs';
import { Passkey, passkey } from '../plugins/passkey.cjs';
export { twoFactorClient } from '../plugins/two-factor.cjs';
import { magicLink } from '../plugins/magic-link.cjs';
import { phoneNumber } from '../plugins/phone-number.cjs';
import { anonymous } from '../plugins/anonymous.cjs';
import { a7 as FieldAttribute, B as BetterAuthOptions, e as BetterAuthPlugin } from '../auth-5gu8kise.cjs';
import { admin } from '../plugins/admin.cjs';
import { genericOAuth } from '../plugins/generic-oauth.cjs';
import { jwt } from '../plugins/jwt.cjs';
import { multiSession } from '../plugins/multi-session.cjs';
import { emailOTP } from '../plugins/email-otp.cjs';
import { Store } from '../types.cjs';
import { sso } from '../plugins/sso.cjs';
import { oidcProvider } from '../plugins/oidc-provider.cjs';
export * from '@simplewebauthn/server';
import 'zod';
import 'better-call';
import 'kysely';
import '../index-IbeXrsdr.cjs';
import 'jose';
import 'better-sqlite3';

interface OrganizationClientOptions {
    ac: AccessControl;
    roles: {
        [key in string]: Role;
    };
}
declare const organizationClient: <O extends OrganizationClientOptions>(options?: O) => {
    id: "organization";
    $InferServerPlugin: ReturnType<typeof organization<{
        ac: O["ac"] extends AccessControl ? O["ac"] : AccessControl<{
            readonly organization: readonly ["update", "delete"];
            readonly member: readonly ["create", "update", "delete"];
            readonly invitation: readonly ["create", "cancel"];
        }>;
        roles: O["roles"] extends Record<string, Role> ? O["roles"] : {
            admin: Role;
            member: Role;
            owner: Role;
        };
    }>>;
    getActions: ($fetch: _better_fetch_fetch.BetterFetch) => {
        $Infer: {
            ActiveOrganization: Prettify<Organization & {
                members: Prettify<Member & {
                    user: {
                        id: string;
                        name: string;
                        email: string;
                        image?: string | null;
                    };
                }>[];
                invitations: Invitation[];
            }>;
            Organization: Organization;
            Invitation: Invitation;
            Member: Member;
        };
        organization: {
            checkRolePermission: <R extends O extends {
                roles: any;
            } ? keyof O["roles"] : "admin" | "member" | "owner">(data: {
                role: R;
                permission: { [key in keyof (O["ac"] extends AccessControl<infer S extends StatementsPrimitive> ? S extends Record<string, any[]> ? S & {
                    readonly organization: readonly ["update", "delete"];
                    readonly member: readonly ["create", "update", "delete"];
                    readonly invitation: readonly ["create", "cancel"];
                } : {
                    readonly organization: readonly ["update", "delete"];
                    readonly member: readonly ["create", "update", "delete"];
                    readonly invitation: readonly ["create", "cancel"];
                } : {
                    readonly organization: readonly ["update", "delete"];
                    readonly member: readonly ["create", "update", "delete"];
                    readonly invitation: readonly ["create", "cancel"];
                })]?: (O["ac"] extends AccessControl<infer S extends StatementsPrimitive> ? S extends Record<string, any[]> ? S & {
                    readonly organization: readonly ["update", "delete"];
                    readonly member: readonly ["create", "update", "delete"];
                    readonly invitation: readonly ["create", "cancel"];
                } : {
                    readonly organization: readonly ["update", "delete"];
                    readonly member: readonly ["create", "update", "delete"];
                    readonly invitation: readonly ["create", "cancel"];
                } : {
                    readonly organization: readonly ["update", "delete"];
                    readonly member: readonly ["create", "update", "delete"];
                    readonly invitation: readonly ["create", "cancel"];
                })[key][number][]; };
            }) => boolean;
        };
    };
    getAtoms: ($fetch: _better_fetch_fetch.BetterFetch) => {
        $listOrg: nanostores.PreinitializedWritableAtom<boolean>;
        $activeOrgSignal: nanostores.PreinitializedWritableAtom<boolean>;
        $activeMemberSignal: nanostores.PreinitializedWritableAtom<boolean>;
        activeOrganization: nanostores.PreinitializedWritableAtom<{
            data: Prettify<{
                id: string;
                createdAt: Date;
                name: string;
                slug: string;
                metadata?: any;
                logo?: string | null | undefined;
            } & {
                members: (Member & {
                    user: {
                        id: string;
                        name: string;
                        email: string;
                        image: string | undefined;
                    };
                })[];
                invitations: Invitation[];
            }> | null;
            error: null | _better_fetch_fetch.BetterFetchError;
            isPending: boolean;
            isRefetching: boolean;
            refetch: () => void;
        }>;
        listOrganizations: nanostores.PreinitializedWritableAtom<{
            data: {
                id: string;
                createdAt: Date;
                name: string;
                slug: string;
                metadata?: any;
                logo?: string | null | undefined;
            }[] | null;
            error: null | _better_fetch_fetch.BetterFetchError;
            isPending: boolean;
            isRefetching: boolean;
            refetch: () => void;
        }>;
        activeMember: nanostores.PreinitializedWritableAtom<{
            data: {
                id: string;
                userId: string;
                createdAt: Date;
                organizationId: string;
                role: string;
            } | null;
            error: null | _better_fetch_fetch.BetterFetchError;
            isPending: boolean;
            isRefetching: boolean;
            refetch: () => void;
        }>;
    };
    pathMethods: {
        "/organization/get-full-organization": "GET";
    };
    atomListeners: ({
        matcher(path: string): path is "/organization/create" | "/organization/update" | "/organization/delete";
        signal: "$listOrg";
    } | {
        matcher(path: string): boolean;
        signal: "$activeOrgSignal";
    } | {
        matcher(path: string): boolean;
        signal: "$activeMemberSignal";
    })[];
};

declare const usernameClient: () => {
    id: "username";
    $InferServerPlugin: ReturnType<typeof username>;
};

declare const getPasskeyActions: ($fetch: BetterFetch, { $listPasskeys, }: {
    $listPasskeys: ReturnType<typeof atom<any>>;
}) => {
    signIn: {
        /**
         * Sign in with a registered passkey
         */
        passkey: (opts?: {
            autoFill?: boolean;
            email?: string;
            fetchOptions?: BetterFetchOption;
        }, options?: BetterFetchOption) => Promise<{
            data: null;
            error: {
                message?: string | undefined;
                status: number;
                statusText: string;
            };
        } | undefined>;
    };
    passkey: {
        /**
         * Add a passkey to the user account
         */
        addPasskey: (opts?: {
            fetchOptions?: BetterFetchOption;
            /**
             * The name of the passkey. This is used to
             * identify the passkey in the UI.
             */
            name?: string;
            /**
             * Try to silently create a passkey with the password manager that the user just signed
             * in with.
             * @default false
             */
            useAutoRegister?: boolean;
        }, fetchOpts?: BetterFetchOption) => Promise<{
            data: null;
            error: {
                message?: string | undefined;
                status: number;
                statusText: string;
            };
        } | undefined>;
    };
    /**
     * Inferred Internal Types
     */
    $Infer: {
        Passkey: Passkey;
    };
};
declare const passkeyClient: () => {
    id: "passkey";
    $InferServerPlugin: ReturnType<typeof passkey>;
    getActions: ($fetch: BetterFetch) => {
        signIn: {
            /**
             * Sign in with a registered passkey
             */
            passkey: (opts?: {
                autoFill?: boolean;
                email?: string;
                fetchOptions?: BetterFetchOption;
            }, options?: BetterFetchOption) => Promise<{
                data: null;
                error: {
                    message?: string | undefined;
                    status: number;
                    statusText: string;
                };
            } | undefined>;
        };
        passkey: {
            /**
             * Add a passkey to the user account
             */
            addPasskey: (opts?: {
                fetchOptions?: BetterFetchOption;
                /**
                 * The name of the passkey. This is used to
                 * identify the passkey in the UI.
                 */
                name?: string;
                /**
                 * Try to silently create a passkey with the password manager that the user just signed
                 * in with.
                 * @default false
                 */
                useAutoRegister?: boolean;
            }, fetchOpts?: BetterFetchOption) => Promise<{
                data: null;
                error: {
                    message?: string | undefined;
                    status: number;
                    statusText: string;
                };
            } | undefined>;
        };
        /**
         * Inferred Internal Types
         */
        $Infer: {
            Passkey: Passkey;
        };
    };
    getAtoms($fetch: BetterFetch): {
        listPasskeys: nanostores.PreinitializedWritableAtom<{
            data: Passkey[] | null;
            error: null | _better_fetch_fetch.BetterFetchError;
            isPending: boolean;
            isRefetching: boolean;
            refetch: () => void;
        }>;
        $listPasskeys: nanostores.PreinitializedWritableAtom<any>;
    };
    pathMethods: {
        "/passkey/register": "POST";
        "/passkey/authenticate": "POST";
    };
    atomListeners: {
        matcher(path: string): path is "/passkey/verify-registration" | "/passkey/delete-passkey" | "/passkey/update-passkey";
        signal: "_listPasskeys";
    }[];
};

declare const magicLinkClient: () => {
    id: "magic-link";
    $InferServerPlugin: ReturnType<typeof magicLink>;
};

declare const phoneNumberClient: () => {
    id: "phoneNumber";
    $InferServerPlugin: ReturnType<typeof phoneNumber>;
    atomListeners: {
        matcher(path: string): path is "/phone-number/verify" | "/phone-number/update";
        signal: "$sessionSignal";
    }[];
};

declare const anonymousClient: () => {
    id: "anonymous";
    $InferServerPlugin: ReturnType<typeof anonymous>;
    pathMethods: {
        "/sign-in/anonymous": "POST";
    };
};

declare const inferAdditionalFields: <T, S extends {
    user?: {
        [key: string]: FieldAttribute;
    };
    session?: {
        [key: string]: FieldAttribute;
    };
} = {}>(schema?: S) => {
    id: "additional-fields-client";
    $InferServerPlugin: ((T extends BetterAuthOptions ? T : T extends {
        options: BetterAuthOptions;
    } ? T["options"] : never) extends never ? S extends {
        user?: {
            [key: string]: FieldAttribute;
        };
        session?: {
            [key: string]: FieldAttribute;
        };
    } ? {
        id: "additional-fields-client";
        schema: {
            user: {
                fields: S["user"] extends object ? S["user"] : {};
            };
            session: {
                fields: S["session"] extends object ? S["session"] : {};
            };
        };
    } : never : (T extends BetterAuthOptions ? T : T extends {
        options: BetterAuthOptions;
    } ? T["options"] : never) extends BetterAuthOptions ? {
        id: "additional-fields";
        schema: {
            user: {
                fields: (T extends BetterAuthOptions ? T : T extends {
                    options: BetterAuthOptions;
                } ? T["options"] : never)["user"] extends {
                    additionalFields: infer U;
                } ? U : {};
            };
            session: {
                fields: (T extends BetterAuthOptions ? T : T extends {
                    options: BetterAuthOptions;
                } ? T["options"] : never)["session"] extends {
                    additionalFields: infer U;
                } ? U : {};
            };
        };
    } : never) extends BetterAuthPlugin ? (T extends BetterAuthOptions ? T : T extends {
        options: BetterAuthOptions;
    } ? T["options"] : never) extends never ? S extends {
        user?: {
            [key: string]: FieldAttribute;
        };
        session?: {
            [key: string]: FieldAttribute;
        };
    } ? {
        id: "additional-fields-client";
        schema: {
            user: {
                fields: S["user"] extends object ? S["user"] : {};
            };
            session: {
                fields: S["session"] extends object ? S["session"] : {};
            };
        };
    } : never : (T extends BetterAuthOptions ? T : T extends {
        options: BetterAuthOptions;
    } ? T["options"] : never) extends BetterAuthOptions ? {
        id: "additional-fields";
        schema: {
            user: {
                fields: (T extends BetterAuthOptions ? T : T extends {
                    options: BetterAuthOptions;
                } ? T["options"] : never)["user"] extends {
                    additionalFields: infer U;
                } ? U : {};
            };
            session: {
                fields: (T extends BetterAuthOptions ? T : T extends {
                    options: BetterAuthOptions;
                } ? T["options"] : never)["session"] extends {
                    additionalFields: infer U;
                } ? U : {};
            };
        };
    } : never : undefined;
};

declare const adminClient: () => {
    id: "better-auth-client";
    $InferServerPlugin: ReturnType<typeof admin>;
    pathMethods: {
        "/admin/list-users": "GET";
        "/admin/stop-impersonating": "POST";
    };
};

declare const genericOAuthClient: () => {
    id: "generic-oauth-client";
    $InferServerPlugin: ReturnType<typeof genericOAuth>;
};

declare const jwtClient: () => {
    id: "better-auth-client";
    $InferServerPlugin: ReturnType<typeof jwt>;
};

declare const multiSessionClient: () => {
    id: "multi-session";
    $InferServerPlugin: ReturnType<typeof multiSession>;
    atomListeners: {
        matcher(path: string): path is "/multi-session/set-active";
        signal: "$sessionSignal";
    }[];
};

declare const emailOTPClient: () => {
    id: "email-otp";
    $InferServerPlugin: ReturnType<typeof emailOTP>;
};

declare global {
    interface Window {
        google?: {
            accounts: {
                id: {
                    initialize: (config: any) => void;
                    prompt: (callback?: (notification: any) => void) => void;
                };
            };
        };
        googleScriptInitialized?: boolean;
    }
}
interface GoogleOneTapOptions {
    /**
     * Google client ID
     */
    clientId: string;
    /**
     * Auto select the account if the user is already signed in
     */
    autoSelect?: boolean;
    /**
     * Cancel the flow when the user taps outside the prompt
     */
    cancelOnTapOutside?: boolean;
    /**
     * The mode to use for the Google One Tap flow
     *
     * popup: Use a popup window
     * redirect: Redirect the user to the Google One Tap flow
     *
     * @default "popup"
     */
    uxMode?: "popup" | "redirect";
    /**
     * The context to use for the Google One Tap flow
     *
     * @default "signin"
     */
    context?: string;
    /**
     * Additional configuration options to pass to the Google One Tap API.
     */
    additionalOptions?: Record<string, any>;
    /**
     * Configuration options for the prompt and exponential backoff behavior.
     */
    promptOptions?: {
        /**
         * Base delay (in milliseconds) for exponential backoff.
         * @default 1000
         */
        baseDelay?: number;
        /**
         * Maximum number of prompt attempts before calling onPromptNotification.
         * @default 5
         */
        maxAttempts?: number;
    };
}
interface GoogleOneTapActionOptions extends Omit<GoogleOneTapOptions, "clientId" | "promptOptions"> {
    fetchOptions?: BetterFetchOption;
    /**
     * Callback URL.
     */
    callbackURL?: string;
    /**
     * Optional callback that receives the prompt notification if (or when) the prompt is dismissed or skipped.
     * This lets you render an alternative UI (e.g. a Google Sign-In button) to restart the process.
     */
    onPromptNotification?: (notification: any) => void;
}
declare const oneTapClient: (options: GoogleOneTapOptions) => {
    id: "one-tap";
    getActions: ($fetch: _better_fetch_fetch.BetterFetch, _: Store) => {
        oneTap: (opts?: GoogleOneTapActionOptions, fetchOptions?: BetterFetchOption) => Promise<void>;
    };
    getAtoms($fetch: _better_fetch_fetch.BetterFetch): {};
};

declare const customSessionClient: <A extends {
    options: BetterAuthOptions;
}>() => {
    id: "infer-server-plugin";
    $InferServerPlugin: (A extends {
        options: infer O;
    } ? O : A)["plugins"] extends (infer P)[] ? P extends {
        id: "custom-session";
    } ? P : never : never;
};

declare const InferServerPlugin: <AuthOrOption extends BetterAuthOptions | {
    options: BetterAuthOptions;
}, ID extends string>() => {
    id: "infer-server-plugin";
    $InferServerPlugin: (AuthOrOption extends {
        options: infer O;
    } ? O : AuthOrOption)["plugins"] extends (infer P)[] ? P extends {
        id: ID;
    } ? P : never : never;
};

declare const ssoClient: () => {
    id: "sso-client";
    $InferServerPlugin: ReturnType<typeof sso>;
};

declare const oidcClient: () => {
    id: "oidc-client";
    $InferServerPlugin: ReturnType<typeof oidcProvider>;
};

export { type GoogleOneTapActionOptions, type GoogleOneTapOptions, InferServerPlugin, adminClient, anonymousClient, customSessionClient, emailOTPClient, genericOAuthClient, getPasskeyActions, inferAdditionalFields, jwtClient, magicLinkClient, multiSessionClient, oidcClient, oneTapClient, organizationClient, passkeyClient, phoneNumberClient, ssoClient, usernameClient };
